 = Android 电源管理 =
 
http://disanji.net/
http://blog.chinaunix.net/space.php?uid=9012903&do=blog&id=2011492
http://blog.csdn.net/droidphone/article/details/6642081
http://blog.csdn.net/lizhiguo0532?viewmode=contents

Android 电源管理在 Linux kernel 基础上增加了 earysuspend 和 wake_lock 两个特性。

* EarlySuspend
  当用户空间向内核请求进入 Suspend 时(如：echo 'standby' > /sys/power/state)，
  内核会先进入 EarlySuspend 状态，同时调用驱动程序注册的回调函数。在 EarlySuspend
  状态，内核会等待所有的 wake_lock 释放，一旦所有的 wake_lock 释放，则立即会调
  用 Linux Kernel 标准的休眠过程。

* WakeLock
  提供这种机制可以阻止内核立即进入Suspend。应用程序可以申请WakeLock，并在适当时候
  释放它，使得内核能够一直等待合适时机才真正进入 Suspend。

== Android 应用层与内核接口层 ==

${ANDROID}/hardware/libhardware_legacy/power/power.c

应用程序调用 set_screen_state(int on) 向 /sys/power/state 写入相应字符串

{{{
static const char *off_state = "mem";
static const char *on_state = "on";
static const char *eink_state = "standby";

int set_screen_state(int on)
{
    ...
    
    char buf[32];
    int len;
    if (on == 1) {
        len = sprintf(buf, "%s", on_state);
        len = write(g_fds[REQUEST_STATE], buf, len);
        ...
    } else if(on == 0){
        len = sprintf(buf, "%s", off_state);
        len = write(g_fds[REQUEST_STATE], buf, len);
	...
    }else if(on == 2){
        len = sprintf(buf, "%s", eink_state);
        len = write(g_fds[REQUEST_STATE], buf, len);
	...
    }

    ...
}

从上述代码可见，android 中电源管理仍是通过向 /sys/power/state 写入字符串来完成的
  }}}
  
== Android 对内核的改动 ==

* kernel/power/

consoleearlysuspend.c
earlysuspend.c
fbearlysuspend.c
userwakelock.c
wakelock.c
include/linux/eralysuspend.h
include/linux/wakelock.h

== EarlySuspend ==

重新来讨论 echo 'standby' > /sys/power/state 此时内核的动作
我们已经打开了 CONFIG_SUSPEND 和 CONFIG_EARLYSUSPEND, state_store 代码经预定义如下
{{{
static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
			   const char *buf, size_t n)
{
	suspend_state_t state = PM_SUSPEND_ON;

	...

	// 根据写入 state 文件的字符串与 pm_states[] 字符串数组中的相比较，决定
	// 当前要进入哪一种模式
	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
			break;
	}
	if (state < PM_SUSPEND_MAX && *s)
		if (state == PM_SUSPEND_ON || valid_state(state)) {
			error = 0;
			request_suspend_state(state);
		}

 Exit:
	return error ? error : n;
}
}}}

原来最后的 *enter_state(state)* 变成了 *request_suspend_state(state)* (kernel/power/earlysuspend.c)

{{{
// state 是本文件内的一个全局变量，记录了当前的电源状态
void request_suspend_state(suspend_state_t new_state)
{
	unsigned long irqflags;
	int old_sleep;

	spin_lock_irqsave(&state_lock, irqflags);
	old_sleep = state & SUSPEND_REQUESTED;
	
	...
	
	if (!old_sleep && new_state != PM_SUSPEND_ON) { // 进入suspend
		state |= SUSPEND_REQUESTED;
		queue_work(suspend_work_queue, &early_suspend_work);
	} else if (old_sleep && new_state == PM_SUSPEND_ON) { // resume
		state &= ~SUSPEND_REQUESTED;
		wake_lock(&main_wake_lock);
		queue_work(suspend_work_queue, &late_resume_work);
	}
	requested_suspend_state = new_state;
	spin_unlock_irqrestore(&state_lock, irqflags);
}
}}}

根据请求的电源状态来决定当前是进入 suspend 还是 resume，进入 suspend 的情况，先
将 early_suspend_work 提交到工作列队，调度执行它们。

{{{
static DECLARE_WORK(early_suspend_work, early_suspend);

static void early_suspend(struct work_struct *work)
{
	struct early_suspend *pos;
	
	...

	list_for_each_entry(pos, &early_suspend_handlers, link) {
		if (pos->suspend != NULL)
			pos->suspend(pos);
	}

	...
	wake_unlock(&main_wake_lock);
	...
}

从 early_suspend_handlers 链表中顺序取出各驱动注册的 eraly_suspend, 然后执行其
中的 suspend 函数。
}}}


{{{
static void late_resume(struct work_struct *work)
{
	struct early_suspend *pos;
	
	...

	list_for_each_entry_reverse(pos, &early_suspend_handlers, link)
		if (pos->resume != NULL)
			pos->resume(pos);
	...
}
从 eraly_suspend_handlers 链表中逆序取出各驱动注册的 eraly_suspend，然后执行其
中的 resume 函数。
}}}

=== eraly_suspend_handlers ===

各驱动通过 register_early_suspend 将 handler 加到 eraly_suspend_handlers 链表里
{{{
void register_early_suspend(struct early_suspend *handler)
{
	struct list_head *pos;

	mutex_lock(&early_suspend_lock);
	list_for_each(pos, &early_suspend_handlers) {
		struct early_suspend *e;
		e = list_entry(pos, struct early_suspend, link);
		if (e->level > handler->level)
			break;
	}
	list_add_tail(&handler->link, pos);
	if ((state & SUSPENDED) && handler->suspend)
		handler->suspend(handler);
	mutex_unlock(&early_suspend_lock);
}
}}}

== WakeLock ==

suspend_work_queue 在 kernel/power/wakelock.c 中创建

上面可以看到，当earlysuspend 时试图 wake_unlock(&main_wake_lock);
每一次解锁或加锁时都会检查系统里的WakeLock锁的状况。

- 当检测到有超时WakeLock时，则拿到超时时间，并用定时器等待超时后， 
  在定时器执行函数中再次检查系统内WakeLock锁的情况。

- 当只剩下非超时锁时，则系统一直不能进入Suspend，直到该非超时锁所有者主动解锁。

- 当内核中检查到没有WakeLock锁了，就可以将工作 suspend_work 提交到工作列队，
  等待调度执行 suspend 进入 Linux 标准的挂起过程。

* wake_lock_init
{{{
void wake_lock_init(struct wake_lock *lock, int type, const char *name)
新建一个锁，指定其类型type 和 名字name，将锁设置为初始状态(未锁住)
最后这个锁加入到 inactive_locks 链表中
}}}

* wake_lock
{{{
void wake_lock(struct wake_lock *lock)
{
	wake_lock_internal(lock, 0, 0);
}
将锁从 inactive_locks 链表中删除， 将锁设置为锁住激活状态(WAKE_LOCK_ACTIVE)
然后加入到 active_wake_locks[type] 链表中
}}}

* wake_unlock
将锁从原链表中删除，并加入到 inactive_locks 链表中，设置成未锁住状态
只要有对 WAKE_LOCK_SUSPEND 类型的锁解锁，就都有可能进入 suspend 状态。
{{{
void wake_unlock(struct wake_lock *lock)
{
	int type;
	unsigned long irqflags;
	spin_lock_irqsave(&list_lock, irqflags);
	type = lock->flags & WAKE_LOCK_TYPE_MASK;
#ifdef CONFIG_WAKELOCK_STAT
	wake_unlock_stat_locked(lock, 0);
#endif
	if (debug_mask & DEBUG_WAKE_LOCK)
		pr_info("wake_unlock: %s\n", lock->name);
	lock->flags &= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
	list_del(&lock->link);
	list_add(&lock->link, &inactive_locks);
	if (type == WAKE_LOCK_SUSPEND) { // 只有WAKE_LOCK_SUSPEND类型的锁才会阻止系统进入suspend
		long has_lock = has_wake_lock_locked(type); // 检查是否还有此类锁存在
		if (has_lock > 0) {
			// 还有超时锁存在，修改定时器超时时间
			if (debug_mask & DEBUG_EXPIRE)
				pr_info("wake_unlock: %s, start expire timer, "
					"%ld\n", lock->name, has_lock);
			mod_timer(&expire_timer, jiffies + has_lock);
		} else {
			if (del_timer(&expire_timer))
				if (debug_mask & DEBUG_EXPIRE)
					pr_info("wake_unlock: %s, stop expire "
						"timer\n", lock->name);
			if (has_lock == 0) // 没有此类锁了，可以进入suspend了
				queue_work(suspend_work_queue, &suspend_work);
			// 如果 has_lock < 0，则说明有非超时锁存在，只能等待非超时锁自己wake_unlock
		}
		if (lock == &main_wake_lock) {
			if (debug_mask & DEBUG_SUSPEND)
				print_active_locks(WAKE_LOCK_SUSPEND);
#ifdef CONFIG_WAKELOCK_STAT
			update_sleep_wait_stats_locked(0);
#endif
		}
	}
	spin_unlock_irqrestore(&list_lock, irqflags);
}
}}}

* 对用户层的接口
在 kernel/power/main.c 中，同 /sys/power/state 文件的创建一样，也存在如下代码：
{{{
power_attr(wake_lock);
power_attr(wake_unlock);
}}}

最后可以得到如下文件：
 /sys/power/wake_lock
 /sys/power/wake_unlock


