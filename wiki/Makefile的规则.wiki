
http://www.linuxsir.org/main/doc/gnumake/GNUmake_v3.80-zh_CN_html/make-04.html

== 规则语法 ==

TARGETS: PREREQUISITES
	COMMAND
	...
或者

TARGETS: PREREQUISITES; COMMAND
	COMMAND
	...

- 当命令行作为独立行时必须以[TAB]字符开始。在第一个规则之后出现的所有以[TAB]字符开始的行都会被当作命令行来处理。
- Makefile中'$'表示变量或函数的引用，在规则中需要使用'$'的地方，需要书写两个连续的'$$'。
- 执行规则命令的条件是以下两者之一：
	# 目标文件不存在
	# 目标文件存在，但规则中依赖文件中的任何一个比目标文件更新(近最后修改时间来比较)。
	
== 依赖 ==

有两种依赖类型：
# 常规依赖
# order-only 依赖
	有时需要定义这样一个规则：目标的重建只由依赖文件中的部分来决定，而不是任一个依赖文件更新后都需要重建目标。
	这种依赖文件称为 order-only 依赖。书写格式如下：

	TARGETS： NORMAL-PREREQUISITES|ORDER-ONLY-PREREQUISITES

	管道符号'|'左边的是常规依赖，右边的是 order-only 依赖。这样的依赖关系中中常规依赖可是是空。
举例：
{{{
LIBS=libtest.a
foo:foo.c|$(LIBS)
	$(CC) $(CFLAGS) $< -o $@ $(LIBS)
  }}}
  
== 文件名通配符 ==

Makefile中通配符只使用在以下两种场合：
# 规则目标、依赖中，make 在读取 Makefile 时会进行匹配处理(通配符展开)。
# 规则命令中，通配符的通配处理是在 shell 执行此条命令时完成的。

除以上两种场合外，不能直接使用通配符，而需要通过 wildcard 函数实现。
{{{
objects = *.o
表示变量 objects 的值是字符串 "*.o"

objects = $(wildcard *.o)
此时objects表示当前目录下的所有 .o 文件。
  }}}
  
一个实际的例子：
{{{
objects := $(patsubst %.c,%.o,$(wildcard *.c))

 foo : $(objects)
 	$(CC) -o foo $(objects)
  }}}
  

== 目录搜索 ==

变量 VPATH 可以指定依赖文件的搜索路径，当规则的依赖文件在当前目录不存在时，make 会在此变量所指定的目录下去寻找这些依赖文件。
通常都用此变量来指定规则的依赖文件的搜索路径。

关键字 vpath 与 变量VPATH 功能类似，但更为灵活，使用方法有三种：

- vpath PATTERN DIRECTORIES
  为所有符合模式 PATTERN 的文件指定搜索目录 DIRECTORIES。多个目录使用 ':' 隔开。
  
- vpath PATTERN
  清除之前为符全 PATTERN 的文件设置的搜索路径。

- vpath
  清除所有已被设置的文件搜索路径。
  
{{{
	vpath %.h ../headers

	Makefile 中出现的 .h 文件，如果不能在当前目录下找到，则到 ../headers 下寻找。
	这里只指示 Makefile 中出现的 .h 文件，并不能指示源文件中包含的 .h 文件的搜索路径。
  }}}
  
== 伪目标 ==

伪目标，它不代表一个真正的目标文件名，在执行 make 时可以指定这个目标来执行其所在规则定义的命令。伪目标也称为标签。

{{{
clean:
	rm *.o

当前工作目录下有与伪目标名相同的文件(存在名为clean的文件)时，由于clean文件是最新，所以
伪目标 clean 下的命令行将不会被执行。使用 .PHONY 声明伪目标可以避免这种问题。
}}}

使用伪目标实现这样一个功能：进入指定子目录中执行命令，遇到错误后会立即退出。

{{{
SUBDIRS := foo bar baz

.PHONY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)

$(SUBDIRS):
	$(MAKE) -C $@
	
foo:baz

最后一行的作用是保证 baz 目录比 foo 先处理。
}}}

== 多目标 ==

一个规则中可以有多个目标，规则所定义的命令对所有目标有效。具有多目标的规则相当于多个规则，所有目标具有相同的依赖文件。
多目标通常使用在以下两种场合：

- 仅需要一个描述依赖的规则，不需要在规则中定义命令，如：
  {{{
  	kdb.o command.o files.o: command.h
    }}}
    
- 多个具有类似重建命令的目标，使用自动变量 $@ 来引用具体目标
  {{{
	bigoutput littleoutput: text.g
	    	generate text.g -$(subst output,$@) > $@
	    	
	这相当于
	bigoutput : text.g
		generate text.g -big > bigoutput
	littleoutput : text.g
		generate text.g -little > littleoutput
    }}}
    
但是多目标的规则并不能做到根据目标文件自动修改依赖文件。

== 静态模式 ==

静态模式规则：规则存在多个目标，并且不同的目标可以根据目标文件的名字构造出依赖文件。

TARGETS ... : TARGET-PATTERN: PREREQ-PATTERN ...
	COMMANDS
	...

{{{
objects = foo.o bar.o
 
all: $(objects)
 
$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
  }}}
  
