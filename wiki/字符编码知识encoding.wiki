= 字符编码的初步认识 =

对编码的认识一直很模糊,这里做了几个小测试,来初步了解一下.
需要申明的是,编码与编码的存储格式是两个不同的概念.比如utf-8 和 ucs-16都是
Unicode编码的一种存储,传输格式.

字符编码的英文是character encoding, 而utf-8是一种格式,即format.了解编码格式时
查了unicode官网的大量资料,从来没有任何一句把utf8描述为encoding. 国内的一些资料
和文献将unicode和utf8都称为'编码',我想这里面肯定是有翻译的原因,但无论如何,它们
根本不是一个层面的东西.

------------------------------------

== 文本的存储 ==

先来做一个小测试
# 用vim新建一个文件/tmp/t,输入'你好'两个字,以utf-8编码保存.用下面的代码读它
{{{
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main(void)
{
	int fd = open("/tmp/t", O_RDWR);
	char ret;

	while (read(fd, &ret, 1) == 1)
		printf("ret = %o\n", (unsigned char)ret);

	close(fd);
	return 0;
}
}}}
其实用od -t x1 /tmp/t 就可以看到, 或hexdump /tmp/t.
{{{
ret = e4
ret = bd
ret = a0
ret = e5
ret = a5
ret = bd
ret = a
}}}
说明此时文件里存储的是 e4 bd a0 e5 a5 bd, 最后的a是换行符'\n'.

# 再用vim打开/tmp/t,并以gb2312编码保存(set fileencoding=gb2312)
{{{
ret = c4
ret = e3
ret = ba
ret = c3
ret = a
}}}
此时存储为 c4 e3 ba c3

---------------------------------------

== GB2312 ==
对于'你'这个字,在GB2312中可作如下分析

{{{
36 67 	<- 查码表中,它在36区的67位上
24 43 	<- 十六进制
a0 a0 + <- 高低位分别加上a0
-----------
c4 e3 	<- 得到'你'的GB2312编码,最后'你'存储为文本便是两个字节:c4e3
}}}

---------------------------------------

== 文本操作 ==
再来一个小测试程序
{{{
#include <stdio.h>

int main(void)
{
	const char *t = "你好";
	printf("%s\n", t);
	while (*t)
		printf("%x\x0a", (unsigned char)*t++);
	printf("\344\275\240\xe5\xa5\xbd\x0a");
	printf("\xe4\xbd\xa0\xe5\xa5\xbd\x0a");
	return 0;
}
}}}
将上面的代码以utf8编码格式保存.编码运行在我的终端得到如下结果:
{{{
你好
e4
bd
a0
e5
a5
bd
你好
你好
}}}
可以得到的信息时此时'你好'存储为 e4 bd a0 e5 a5 bd

而把代码保存为gb2312,则得到的结果为:
{{{
���
c4
e3
ba
c3
你好
你好
}}}
第一行得到的是乱码.而最后两行却得到了正确的显示.在打印时,printf只管把字符'丢'
给终端(stdout), 而具体如何解释这些字符,就是终端的工作了.我的终端现在的
character encoding 设置为utf8,所以最后两行的字符被成功解释为'你好'.第一行的字
符按utf8的编码格式来解释不能成功,显示为乱码.

--------------------------------------------

== 小结 ==
读一个文本文件时,拿到的是它们存储在磁本上的数据.如何处理这些数据,正确的解析它
们,并最终正确的显示在屏幕上,这中间有几个步骤:
# 读入数据
# 解析它是何种编码(可以看一下enca的代码)
# 得到编码后就需要字库引擎了
	- 到字库里去找这个字符对应的字形
	- 或转为某一编码格式,然后再去找字符对应的字形
# 拿到字形,画到屏幕上
 
*以上仅是我现在的理解*
