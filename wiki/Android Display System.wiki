
FramebufferNativeWindow

hw_get_module("gralloc", &module)

1. 从环境变量中找到 "imx5x"
2. 在 "/system/lib/hw" 和 "/vendor/lib/hw" 两个路径下
3. 拼成 /system/lib/hw/gralloc.imx5x.so，并确认此文件存在
4. 用 dl 函数族 load 这个动态库，并在库中找到符号"HMI"并把其地址赋给module给供返回

framebuffer_open/gralloc_open 等操作具体硬件设备都是平台相关的，
正因为如此才要在上面费一大圈的力气去找到对应的 module 。module 里
就有对应平台设备操作方法的实现。

操作完之后将信息存储在 fbDev 和 grDev 中。

== FramebufferNativeWindow ==

frameworks/base/libs/ui/FramebufferNativeWindow.cpp 

{{{
    81	FramebufferNativeWindow::FramebufferNativeWindow() 
    82	    : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false)
    83	{
    84	    hw_module_t const* module;
    /*
     * 先看下面的 hw_get_module 分析，hw_get_module 最后会获得 GRALLOC 这个设
     * 备模块的描述指针，在本篇的后面，大概是
     *
        common: {
            tag: HARDWARE_MODULE_TAG,
            version_major: 1,
            version_minor: 0,
            id: GRALLOC_HARDWARE_MODULE_ID,
            name: "Graphics Memory Allocator Module",
            author: "The Android Open Source Project",
            methods: &gralloc_module_methods
	},  
     */
    85	    if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module) == 0) {
    86	        int stride;
    87	        int err;
    88	        int i;
    89	        err = framebuffer_open(module, &fbDev);
    90	        LOGE_IF(err, "couldn't open framebuffer HAL (%s)", strerror(-err));
    91	        
    92	        err = gralloc_open(module, &grDev);
    93	        LOGE_IF(err, "couldn't open gralloc HAL (%s)", strerror(-err));
    94	
    95	        // bail out if we can't initialize the modules
    96	        if (!fbDev || !grDev)
    97	            return;
    98	        
    99	        mUpdateOnDemand = (fbDev->setUpdateRect != 0);
   100	        
   101	        // initialize the buffer FIFO
   102	        mNumBuffers = fbDev->reserved[0];
   103	        if (mNumBuffers != 3 && mNumBuffers != 2) {
   104	            LOGE("The framebuffer number got from HAL is not supported(%d)", mNumBuffers);
   105	            return;
   106	        }
   107	        mNumFreeBuffers = mNumBuffers;
   108	
   109	        mBufferHead = mNumBuffers-1;
   110	
   111	        for (i = 0; i < mNumBuffers; i++)
   112	            buffers[i] = new NativeBuffer(
   113	                    fbDev->width, fbDev->height, fbDev->format, GRALLOC_USAGE_HW_FB);
   114	
   115	        for (i = 0; i < mNumBuffers; i++) {
   116	            err = grDev->alloc(grDev,
   117	                    fbDev->width, fbDev->height, fbDev->format,
   118	                    GRALLOC_USAGE_HW_FB, &buffers[i]->handle, &buffers[i]->stride);
   119	
   120	            LOGE_IF(err, "fb buffer %d allocation failed w=%d, h=%d, err=%s",
   121	                    i, fbDev->width, fbDev->height, strerror(-err));
   122	        }
   123	
   124	        const_cast<uint32_t&>(ANativeWindow::flags) = fbDev->flags; 
   125	        const_cast<float&>(ANativeWindow::xdpi) = fbDev->xdpi;
   126	        const_cast<float&>(ANativeWindow::ydpi) = fbDev->ydpi;
   127	        const_cast<int&>(ANativeWindow::minSwapInterval) = 
   128	            fbDev->minSwapInterval;
   129	        const_cast<int&>(ANativeWindow::maxSwapInterval) = 
   130	            fbDev->maxSwapInterval;
   131	    } else {
   132	        LOGE("Couldn't get gralloc module");
   133	    }
   134	
   135	    ANativeWindow::setSwapInterval = setSwapInterval;
   136	    ANativeWindow::dequeueBuffer = dequeueBuffer;
   137	    ANativeWindow::lockBuffer = lockBuffer;
   138	    ANativeWindow::queueBuffer = queueBuffer;
   139	    ANativeWindow::query = query;
   140	    ANativeWindow::perform = perform;
   141	}
}}}

== gralloc_device_open ==

 hardware/mx5x/libgralloc/gralloc.c   
 
{{{
static struct hw_module_methods_t gralloc_module_methods = {
        open: gralloc_device_open
};
}}}
gralloc_module_methods 中提供了 open

{{{
在 hardware/libhardware/include/hardware/gralloc.h 中有
static inline int gralloc_open(const struct hw_module_t* module, 
        struct alloc_device_t** device) {
    return module->methods->open(module, 
            GRALLOC_HARDWARE_GPU0, (struct hw_device_t**)device);
}

static inline int framebuffer_open(const struct hw_module_t* module, 
        struct framebuffer_device_t** device) {
    return module->methods->open(module, 
            GRALLOC_HARDWARE_FB0, (struct hw_device_t**)device);
}
就用用gralloc_device_open 分别打开设备 "gpu0" 和 "fb0"
}}}

== hw_get_module ==

{{{
    31	#define HAL_LIBRARY_PATH1 "/system/lib/hw"
    32	#define HAL_LIBRARY_PATH2 "/vendor/lib/hw"
    33	
    34	/**
    35	 * There are a set of variant filename for modules. The form of the filename
    36	 * is "<MODULE_ID>.variant.so" so for the led module the Dream variants 
    37	 * of base "ro.product.board", "ro.board.platform" and "ro.arch" would be:
    38	 *
    39	 * led.trout.so
    40	 * led.msm7k.so
    41	 * led.ARMV6.so
    42	 * led.default.so
    43	 */
    44	
    45	static const char *variant_keys[] = {
    46	    "ro.hardware",  /* This goes first so that it can pick up a different
    47	                       file on the emulator. */
    48	    "ro.product.board",
    49	    "ro.board.platform",
    50	    "ro.arch"
    51	};
    52	
    53	static const int HAL_VARIANT_KEYS_COUNT =
    54	    (sizeof(variant_keys)/sizeof(variant_keys[0]));

   120	int hw_get_module(const char *id, const struct hw_module_t **module) 
   121	{
   122	    int status;
   123	    int i;
   124	    const struct hw_module_t *hmi = NULL;
   125	    char prop[PATH_MAX];
   126	    char path[PATH_MAX];
   127	
   128	    /*
   129	     * Here we rely on the fact that calling dlopen multiple times on
   130	     * the same .so will simply increment a refcount (and not load
   131	     * a new copy of the library).
   132	     * We also assume that dlopen() is thread-safe.
   133	     */
   134	
   135	    /* Loop through the configuration variants looking for a module */
   136	    for (i=0 ; i<HAL_VARIANT_KEYS_COUNT+1 ; i++) {
   137	        if (i < HAL_VARIANT_KEYS_COUNT) {
   138	            if (property_get(variant_keys[i], prop, NULL) == 0) {
   139	                continue;
   140	            }
   
            /*
	     * HAL_LIBRARY_PATH1/ id  /prop
	     * /system/lib/hw/gralloc.imx5x.so
	     * 找到之后立即退出循环
	     */
   141	            snprintf(path, sizeof(path), "%s/%s.%s.so",
   142	                    HAL_LIBRARY_PATH1, id, prop);
   143	            if (access(path, R_OK) == 0) break;
   144	
   145	            snprintf(path, sizeof(path), "%s/%s.%s.so",
   146	                     HAL_LIBRARY_PATH2, id, prop);
   147	            if (access(path, R_OK) == 0) break;
   148	        } else {
   149	            snprintf(path, sizeof(path), "%s/%s.default.so",
   150	                     HAL_LIBRARY_PATH1, id);
   151	            if (access(path, R_OK) == 0) break;
   152	        }
   153	    }
   154	
   155	    status = -ENOENT;
   156	    if (i < HAL_VARIANT_KEYS_COUNT+1) {
   157	        /* load the module, if this fails, we're doomed, and we should not try
   158	         * to load a different variant. */
   159	        status = load(id, path, module);
   160	    }
   161	
   162	    return status;
   163	}
}}}

{{{
load("gralloc", "/system/lib/hw/gralloc.imx5x.so", module)

    61	static int load(const char *id,
    62	        const char *path,
    63	        const struct hw_module_t **pHmi)
    64	{
    65	    int status;
    66	    void *handle;
    67	    struct hw_module_t *hmi;
    68	
    69	    /*
    70	     * load the symbols resolving undefined symbols before
    71	     * dlopen returns. Since RTLD_GLOBAL is not or'd in with
    72	     * RTLD_NOW the external symbols will not be global
    73	     */
    74	    handle = dlopen(path, RTLD_NOW);
    75	    if (handle == NULL) {
    76	        char const *err_str = dlerror();
    77	        LOGE("load: module=%s\n%s", path, err_str?err_str:"unknown");
    78	        status = -EINVAL;
    79	        goto done;
    80	    }
    81	
    
    /*
     * libhardware/include/hardware/hardware.h:
     * #define HAL_MODULE_INFO_SYM_AS_STR  "HMI"
     * 
     * 操作 "/system/lib/hw/gralloc.imx5x.so" 库
     * dlopen 打开这个库，将其load到内存中
     * dlsym 在库中查找"HMI"这个符号，找到的话则返回它在内存中的地址
     */
     
    82	    /* Get the address of the struct hal_module_info. */
    83	    const char *sym = HAL_MODULE_INFO_SYM_AS_STR;
    84	    hmi = (struct hw_module_t *)dlsym(handle, sym);
    85	    if (hmi == NULL) {
    86	        LOGE("load: couldn't find symbol %s", sym);
    87	        status = -EINVAL;
    88	        goto done;
    89	    }
    90	
    91	    /* Check that the id matches */
    92	    if (strcmp(id, hmi->id) != 0) {
    93	        LOGE("load: id=%s != hmi->id=%s", id, hmi->id);
    94	        status = -EINVAL;
    95	        goto done;
    96	    }
    97	
    98	    hmi->dso = handle;
    99	
   100	    /* success */
   101	    status = 0;
   102	
   103	    done:
   104	    if (status != 0) {
   105	        hmi = NULL;
   106	        if (handle != NULL) {
   107	            dlclose(handle);
   108	            handle = NULL;
   109	        }
   110	    } else {
   111	        LOGV("loaded HAL id=%s path=%s hmi=%p handle=%p",
   112	                id, path, *pHmi, handle);
   113	    }
   114	
   115	    *pHmi = hmi;
   116	
   117	    return status;
   118	}
  }}}
  
那么在库中找到"HMI"这个符号就是找到了hw_module_t这个结构体的首地址，这是什么原理呢？

读出这个库的符号，可以得到如下信息
{{{
linux@debian:hw$ readelf -s gralloc.imx5x.so

Symbol table '.dynsym' contains 113 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
   	...
    39: 00000000     0 FUNC    GLOBAL DEFAULT  UND free
    40: 00000000     0 FUNC    GLOBAL DEFAULT  UND __aeabi_atexit
    41: 00006e40     0 NOTYPE  GLOBAL DEFAULT   17 __dso_handle
    _*42: 00006254   452 OBJECT  GLOBAL DEFAULT   16 HMI*_
    43: 000042a5    44 FUNC    GLOBAL DEFAULT    7 _Z23gralloc_register_buff
    44: 00004361    96 FUNC    GLOBAL DEFAULT    7 _Z25gralloc_unregister_bu
    45: 000041bd   232 FUNC    GLOBAL DEFAULT    7 _Z12gralloc_lockPK16grall
    46: 000040f1   104 FUNC    GLOBAL DEFAULT    7 _Z14gralloc_unlockPK16gra
    47: 00000000     0 FUNC    GLOBAL DEFAULT  UND glFinish
   	...
  }}}
  
在 hardware 目录下搜索 HAL_MODULE_INFO_SYM 会得到许多结构体定义

查看 mx5x/libgralloc/gralloc.cpp ， 有：

{{{
    86	struct private_module_t HAL_MODULE_INFO_SYM = {
    87	    base: {
    88	        common: {
    89	            tag: HARDWARE_MODULE_TAG,
    90	            version_major: 1,
    91	            version_minor: 0,
    92	            id: GRALLOC_HARDWARE_MODULE_ID,
    93	            name: "Graphics Memory Allocator Module",
    94	            author: "The Android Open Source Project",
    95	            methods: &gralloc_module_methods
    96	        },
    97	        registerBuffer: gralloc_register_buffer,
    98	        unregisterBuffer: gralloc_unregister_buffer,
    99	        lock: gralloc_lock,
   100	        unlock: gralloc_unlock,
   101	    },
   102	    framebuffer: 0,
   103	    flags: 0,
   104	    numBuffers: 0,
   105	    bufferMask: 0,
   106	    lock: PTHREAD_MUTEX_INITIALIZER,
   107	    currentBuffer: 0,
   108	    pmem_master: -1,
   109	    pmem_master_base: 0,
   110	    master_phys: 0
   111	};
}}}

在 hardware/libhardware/include/hardware/hardware.h 中有
#define HAL_MODULE_INFO_SYM         HMI
这个结构体名实际为 HMI ，这就是它在 .so 中的符号

hardware/mx5x/libgralloc/gralloc_priv.h :
	结构体 private_module_t 第一个成员为 gralloc_module_t base;
	
hardware/libhardware/include/hardware/gralloc.h :
	gralloc_module_t 第一个成员为 struct hw_module_t common;

最后返回的 HMI 结构体的首地址也即 hw_module_t 的首地址


通过这个过程可以了解到，每个相应硬件设备都有一个 HMI 的结构体，且最终各设备都有
独立的库位于 /system/lib/hw/ 下
