
http://blog.csdn.net/a345017062/article/details/6417929

从 [[linux-input-system-2|linux input system]] 中可以了解到，
读 /dev/input/ 下的某个设备文件即可得到我们想要的事件。

android 继而的处理流程为：

frameworks/base/libs/ui/EventHub.cpp

http://hi.baidu.com/zhouhanqing/blog/item/9d18a3cc16020a580eb3451c.html

frameworks/base/services/jni/com_android_server_KeyInputQueue.cpp


frameworks/base/libs/ui/EventHub.cpp

bool InputReaderThread::threadLoop()    //InputReader.cpp
void InputReader::loopOnce()    //InputReader.cpp
  -> bool EventHub::getEvent(RawEvent* outEvent)     //EventHub.cpp



InputReader::process
  -> InputReader::addDevice
     -> InputReader::createDevice
  -> InputReader::consumeEvent
  

{{{
           WindowmanagerService 
                              \ 
                               \
 = java ===================   InputManager
                                   ^
                                   |
 = jni ===============    --> com_android_server_InputManager
                         /
                        /       
               InputManager
               /        \          
              /          \
       InputReader     InputDispatcher
           ^        
           |
        EventHub
  }}}
  
EventHub::getEvent
将事件分为几类，DEVICE_ADDED/DEVICE_REMOVED/FINISHED_DEVICE_SCAN。扫描到的事件放入mInputBufferData

InputReader
拿到事件之后(InputReader::loopOnce())，根据事件类型不同处理：分别是

{{{
void InputReader::process(const RawEvent* rawEvent) {
    switch (rawEvent->type) {
    case EventHubInterface::DEVICE_ADDED:
        addDevice(rawEvent->deviceId);
        break;

    case EventHubInterface::DEVICE_REMOVED:
        removeDevice(rawEvent->deviceId);
        break;

    case EventHubInterface::FINISHED_DEVICE_SCAN:
        handleConfigurationChanged(rawEvent->when);
        break;

    default:
        consumeEvent(rawEvent);
        break;
    }
}
}}}

addDevice 添加输入设备时，会根据输入设备的类型分为不同的classes，这与 kernel
驱动中的设备类型呼应，都有：
{{{
INPUT_DEVICE_CLASS_KEYBOARD       /* The input device is a keyboard. */
INPUT_DEVICE_CLASS_ALPHAKEY       /* The input device is an alpha-numeric keyboard (not just a dial pad). */
INPUT_DEVICE_CLASS_TOUCHSCREEN    /* The input device is a touchscreen (either single-touch or multi-touch). */
INPUT_DEVICE_CLASS_TRACKBALL      /* The input device is a trackball. */
INPUT_DEVICE_CLASS_TOUCHSCREEN_MT /* The input device is a multi-touch touchscreen. */
INPUT_DEVICE_CLASS_DPAD           /* The input device is a directional pad (implies keyboard, has DPAD keys). */
INPUT_DEVICE_CLASS_GAMEPAD        /* The input device is a gamepad (implies keyboard, has BUTTON keys). */
INPUT_DEVICE_CLASS_SWITCH         /* The input device has switches. */
INPUT_DEVICE_CLASS_MOUSE          /* The input device is a mouse. */
}}}

每种class的设备都有自己的一套事件处理方法，封装为 InputMapper。

InputReader::consumeEvent 中处理事件，会根据事件的ID拿到不同的 InputMapper, 
然后调用不同的处理函数将事件向上发送。









EventHub::openPlatformInput
 --> scanDir 扫描 /dev/input 目录
     --> openDevice
         打开 /dev/input/ 下的每一个文件，并用ioctrl拿到各个设备文件的信息，包括
       
         EVIOCGVERSION        /* get driver version */
         EVIOCGID             /* get device ID */
         EVIOCGNAME(len)      /* get device name */
         EVIOCGPHYS(len)      /* get physical location */
         EVIOCGUNIQ(len)      /* get unique identifier */
         EVIOCGBIT(ev,len)    /* get event bits */
         
	并为该设备新建一个 device_t 的 device，并最后检测设备类型(class)
	如果是键盘，还要找并加载键值映射文件

