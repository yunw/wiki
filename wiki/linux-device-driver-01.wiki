
- probe 函数什么时候被调用？
- 如何确定各 probe 函数的调用顺序？
- bus 上的设备是如何注册的？


== 启动顺序 ==

include/linux/init.h 中有如何定义：

{{{
#define pure_initcall(fn)		__define_initcall("0",fn,0)

#define core_initcall(fn)		__define_initcall("1",fn,1)
#define core_initcall_sync(fn)		__define_initcall("1s",fn,1s)
#define postcore_initcall(fn)		__define_initcall("2",fn,2)
#define postcore_initcall_sync(fn)	__define_initcall("2s",fn,2s)
#define arch_initcall(fn)		__define_initcall("3",fn,3)
#define arch_initcall_sync(fn)		__define_initcall("3s",fn,3s)
#define subsys_initcall(fn)		__define_initcall("4",fn,4)
#define subsys_initcall_sync(fn)	__define_initcall("4s",fn,4s)
#define fs_initcall(fn)			__define_initcall("5",fn,5)
#define fs_initcall_sync(fn)		__define_initcall("5s",fn,5s)
#define rootfs_initcall(fn)		__define_initcall("rootfs",fn,rootfs)
#define device_initcall(fn)		__define_initcall("6",fn,6)
#define device_initcall_sync(fn)	__define_initcall("6s",fn,6s)
#define late_initcall(fn)		__define_initcall("7",fn,7)
#define late_initcall_sync(fn)		__define_initcall("7s",fn,7s)

#define __initcall(fn) device_initcall(fn)

...

#define module_init(x)	__initcall(x);

}}}

wlan_src/mlinux/moal_main.c 中有
{{{
module_init(woal_init_module);
  }}}
在 linux 启动自举时，会在 device_initcall 这一步调用所有 module_init
声明的函数。

*woal_init_module()*
  -> *woal_bus_register()*
     -> sdio_register_driver(&wlan_sdio)  // 这里开始进入 sdio 驱动程序注册
        -> driver_register(&drv->drv)
           -> driver_find(drv->name, drv->bus) // 查找此名字的驱动在bus上是否注册，保证此驱动之前未注册过
           -> bus_add_driver(drv) // 将drv注册到drv->bus总线上
              -> driver_attach(drv) // drivers_autoprobe 在 bus_register 时置为1了，
				    // 这里试图将驱动与设备连接起来
                 -> bus_for_each_dev(drv->bus, NULL, drv, __driver_attach)
                    遍历drv->bus上所有的设备并为每个设备调用__driver_attach，尝试与drv连接

__driver_attach(drv, data)
  -> driver_match_dvice(drv, dev)
  -> *driver_probe_device(drv, dev)*

===============================

device_register(struct device *dev)
  -> device_initialize(dev);
  -> device_add(dev);
    -> bus_probe_device(dev);
       -> device_attach(dev);
          -> bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
          遍历dev所在的总线上的drv，将每一个找到的drv执行__device_attach，尝着与dev连接
   
__device_attach(drv, data) // struct device *dev = data;
  -> driver_match_device(drv, dev) // 先检查此drv与dev是否匹配，如果不匹配则直接返回
  -> *driver_probe_device(drv, dev)* // 如果drv与dev匹配，则尝试进行probe动作

===============================
  
*driver_probe_device(drv, dev)* // 此函数尝试绑定设备和驱动，成功返回1，否则返回0
  -> 1. dev->bus->probe()    // 如果设备所在的总线bus有probe，则执行bus的probe函数
  -> 2. drv->probe() // 如果总线bus上没有probe，则看drv上是否有probe，如果有则执行它

{{{
static inline int driver_match_device(struct device_driver *drv,
				      struct device *dev)
{
	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
}
}}}
