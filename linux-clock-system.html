<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css" />
<title>linux-clock-system</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>


<p>
arch/arm/mach-5x/clock.c
</p>

<pre>

struct clk_lookup {
	struct list_head	node;
	const char		*dev_id;
	const char		*con_id;
	struct clk		*clk;
};

static struct clk_lookup mx53_lookups[] = {
	...
};

struct mxc_clk {
	struct list_head node;
	char name[20];
	struct clk *reg_clk;
};

static struct mxc_clk mx53_clks[ARRAY_SIZE(lookups) + ARRAY_SIZE(mx53_lookups)];
</pre>


<p>
mx53_hs13_timer_init()
	mx53_clocks_init(32768, 24000000, 22579200, 0);
	mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
</p>
	
	
<pre>
int __init mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
{
	__iomem void *base;
	struct clk *tclk;
	int i = 0, j = 0, reg;
	u32 pll1_rate;

	// 映射pll基地址
	pll1_base = ioremap(MX53_BASE_ADDR(PLL1_BASE_ADDR), SZ_4K);
	pll2_base = ioremap(MX53_BASE_ADDR(PLL2_BASE_ADDR), SZ_4K);
	pll3_base = ioremap(MX53_BASE_ADDR(PLL3_BASE_ADDR), SZ_4K);
	pll4_base = ioremap(MX53_BASE_ADDR(PLL4_BASE_ADDR), SZ_4K);

	/* Turn off all possible clocks */
	// 设置 CCGR(0~7) 寄存器，关闭/打开各外设的clock
	...

	...

	clk_tree_init();

	// 1. 把 lookups[] 里的 clock 都加到 arch/arm/common/clkdev.c里的clocks链表上，
	// 2. 用 loopups[] 里的元素填充mx53_clks[]
	// 3. 把 mx53_clks[] 里的元素注册到 arch/arm/plat-mxc/clocks.c 里的clocks链表上
	for (i = 0; i &lt; ARRAY_SIZE(lookups); i++) {
		clkdev_add(&amp;lookups[i]);
		mx53_clks[i].reg_clk = lookups[i].clk;
		if (lookups[i].con_id != NULL)
			strcpy(mx53_clks[i].name, lookups[i].con_id);
		else
			strcpy(mx53_clks[i].name, lookups[i].dev_id);
		clk_register(&amp;mx53_clks[i]);
	}

	// 1. 把 mx53_lookups[] 里的 clock 都加到 arch/arm/common/clkdev.c里的clocks链表上，
	// 2. 用 mx53_loopups[] 里的元素填充mx53_clks[]
	// 3. 把 mx53_clks[] 里的元素注册到 arch/arm/plat-mxc/clocks.c 里的clocks链表上
	...

	clk_set_parent(&amp;esai_clk[0], &amp;ckih_clk);

	ldb_di_clk[0].parent = ldb_di_clk[1].parent =
	tve_clk.parent = &amp;pll4_sw_clk;

	max_axi_a_clk = MAX_AXI_A_CLK_MX53;
	max_axi_b_clk = MAX_AXI_B_CLK_MX53;
	max_ahb_clk = MAX_AHB_CLK_MX53;
	max_emi_slow_clk = MAX_AHB_CLK_MX53;

	mx53_revision();

	/* set DDR clock parent */
	reg = __raw_readl(MXC_CCM_CBCMR) &amp;
				MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
	reg &gt;&gt;= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
	if (reg == 0) {
		tclk = &amp;axi_a_clk;
	} else if (reg == 1) {
		tclk = &amp;axi_b_clk;
	} else if (reg == 2) {
		tclk = &amp;emi_slow_clk;
	} else {
		tclk = &amp;ahb_clk;
	}
	clk_set_parent(&amp;ddr_clk, tclk);

	clk_set_parent(&amp;esdhc1_clk[2], &amp;tmax2_clk);
	clk_set_parent(&amp;esdhc2_clk[0], &amp;esdhc1_clk[0]);
	clk_set_parent(&amp;esdhc3_clk[0], &amp;pll2_sw_clk);

#if 0
	/*Setup the LPM bypass bits */
	reg = __raw_readl(MXC_CCM_CLPCR);
	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS
		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
	__raw_writel(reg, MXC_CCM_CLPCR);
#endif

	clk_enable(&amp;cpu_clk);

	clk_enable(&amp;main_bus_clk);

	/* Set AXI_B_CLK to be 200MHz */
	clk_set_rate(&amp;axi_b_clk, 200000000);

	/* Initialise the parents to be axi_b, parents are set to
	 * axi_a when the clocks are enabled.
	 */

	clk_set_parent(&amp;vpu_clk[0], &amp;axi_b_clk);
	clk_set_parent(&amp;vpu_clk[1], &amp;axi_b_clk);

	/* move cspi to 24MHz */
	clk_set_parent(&amp;cspi_main_clk, &amp;lp_apm_clk);
	clk_set_rate(&amp;cspi_main_clk, 12000000);
	/*move the spdif0 to spdif_xtal_ckl */
	clk_set_parent(&amp;spdif0_clk[0], &amp;spdif_xtal_clk);
	/*set the SPDIF dividers to 1 */
	reg = __raw_readl(MXC_CCM_CDCDR);
	reg &amp;= ~MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK;
	reg &amp;= ~MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK;
	__raw_writel(reg, MXC_CCM_CDCDR);

	/* Move SSI clocks to SSI_LP_APM clock */
	clk_set_parent(&amp;ssi_lp_apm_clk, &amp;lp_apm_clk);

	clk_set_parent(&amp;ssi1_clk[0], &amp;ssi_lp_apm_clk);
	/* set the SSI dividers to divide by 2 */
	reg = __raw_readl(MXC_CCM_CS1CDR);
	reg &amp;= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
	reg &amp;= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
	reg |= 1 &lt;&lt; MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
	__raw_writel(reg, MXC_CCM_CS1CDR);

	clk_set_parent(&amp;ssi2_clk[0], &amp;ssi_lp_apm_clk);
	reg = __raw_readl(MXC_CCM_CS2CDR);
	reg &amp;= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
	reg &amp;= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
	reg |= 1 &lt;&lt; MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
	__raw_writel(reg, MXC_CCM_CS2CDR);

	/* Change the SSI_EXT1_CLK to be sourced from PLL2 for camera */
	clk_disable(&amp;ssi_ext1_clk);
	clk_set_parent(&amp;ssi_ext1_clk, &amp;pll2_sw_clk);
	clk_set_rate(&amp;ssi_ext1_clk, 24000000);
	clk_enable(&amp;ssi_ext1_clk);
	clk_set_parent(&amp;ssi_ext2_clk, &amp;ssi2_clk[0]);

	/* move usb_phy_clk to 24MHz */
	clk_set_parent(&amp;usb_phy_clk[0], &amp;osc_clk);
	clk_set_parent(&amp;usb_phy_clk[1], &amp;osc_clk);

	/* set usboh3_clk to pll2 */
	clk_set_parent(&amp;usboh3_clk[0], &amp;pll2_sw_clk);
	reg = __raw_readl(MXC_CCM_CSCDR1);
	reg &amp;= ~MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK;
	reg &amp;= ~MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK;
	reg |= 4 &lt;&lt; MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET;
	reg |= 1 &lt;&lt; MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET;
	__raw_writel(reg, MXC_CCM_CSCDR1);

	/* set SDHC root clock as 200MHZ*/
	clk_set_rate(&amp;esdhc1_clk[0], 200000000);
	clk_set_rate(&amp;esdhc3_clk[0], 200000000);

	 /* Set the 1588 RTC input clocks as 108MHZ */
	clk_set_parent(&amp;ieee_rtc_clk, &amp;pll3_sw_clk);
	clk_set_rate(&amp;ieee_rtc_clk, 108000000);

	/* The CPU working point should be set according to part number
	 * information. But part number information is not clear now.
	 * So update the cpu working point table based on the PLL1 freq
	 * at boot time
	 */
	pll1_rate = clk_get_rate(&amp;pll1_main_clk);

	if (pll1_rate &gt; 1000000000)
		mx53_set_cpu_part_number(IMX53_CEC_1_2G);
	else if (pll1_rate &gt; 800000000)
		mx53_set_cpu_part_number(IMX53_CEC);
	else
		mx53_set_cpu_part_number(IMX53_AEC);

	/* Set the current working point. */
	cpu_wp_tbl = get_cpu_wp(&amp;cpu_wp_nr);
	for (i = 0; i &lt; cpu_wp_nr; i++) {
		if (clk_get_rate(&amp;cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
			cpu_curr_wp = i;
			break;
		}
	}
	if (i &gt; cpu_wp_nr)
		BUG();

	clk_set_parent(&amp;arm_axi_clk, &amp;axi_b_clk);
	clk_set_parent(&amp;ipu_clk[0], &amp;axi_b_clk);
	clk_set_parent(&amp;gpu3d_clk[0], &amp;axi_b_clk);
	clk_set_parent(&amp;gpu2d_clk, &amp;axi_b_clk);

	clk_set_parent(&amp;emi_slow_clk, &amp;ahb_clk);
	clk_set_rate(&amp;emi_slow_clk, clk_round_rate(&amp;emi_slow_clk, 133333333));

	clk_set_rate(&amp;emi_enfc_clk, clk_round_rate(&amp;emi_enfc_clk,
			MAX_NFC_CLK));

	/* set the freq of asrc_serial_clk */
	clk_set_rate(&amp;asrc_clk[0], clk_round_rate(&amp;asrc_clk[0],
			1190000));
	base = ioremap(MX53_BASE_ADDR(GPT1_BASE_ADDR), SZ_4K);
	mxc_timer_init(&amp;gpt_clk[0], base, MXC_INT_GPT);
	return 0;
}
</pre>

</body>
</html>
