<html>
<head>
<link rel="Stylesheet" type="text/css" href="../style.css" />
<title>irq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>

<p>
同事在调试一个外设时发现：
a. 系统正常运行的情况下，使用这个设备会触发中断并调用它的中断处理函数。
b. 系统休眠之后，使用这个设备可以唤醒系统，但中断处理函数却没有被调用。
</p>

<p>
能够唤醒系统，说明中断一定是触发了。另发现小板上的键盘是可以的，休眠后按键可以
调到keyboard的中断处理函数。
</p>

<p>
跟踪这个问题，发现以下几点：
</p>

<p>
1. Linux在系统休眠时会调用dpm_suspend_noirq()-&gt; suspend_device_irqs()。
</p>

<p>
  当系统休眠时，设备驱动需要禁止接收中断，suspend_device_irqs()屏蔽所有正在
  使用的中断(置IRQ_DISABLED标志)，timer中断除外，因为Timer中段标志中设置了
  IRQF_NO_SUSPEND。如果禁止原因是suspend，则设置标志中的IRQ_SUSPENDED位。
</p>

<p>
  所以休眠之后，desc-&gt;status |= IRQ_DISABLED;
</p>
  
<p>
2. 中断触发类型有很多种，比如边沿触发和电平触发。在Linux里分别用
   handle_edge_irq() / handle_level_irq() 来处理它们。
</p>

<p>
  handle_edge_irq() : 
</p>
<ul>
<li>
如果中断有标志 IRQ_INPROGRESS 或 IRQ_DISABLED，说明此中断已经在处理或
<br />	  已经禁止。边沿触发锁存这次中断请求(置标记IRQ_PENDING)，然后退出。
<br />	  由于中断请求已经锁存了，所以中断处理函数一定会被调用到。
</li>
</ul>

<p>
  handle_level_irq() : 
</p>
<ul>
<li>
电平都会延续一段时间，在这段时间内电平中断会一直被触发。因此进入电平
<br />	  中断处理之前会先屏蔽该中断，到最后处理完毕之后再开启。
</li>
</ul>
	  
<p>
	*
	电平触发不允许嵌套。正在处理的中断(IRQ_INPROGRESS)或被禁止的中断都不会
	  请求。
</p>
	  
<ul>
<li>
handle_level_irq()中如果发现中断是IRQ_DISABLED，则会直接退出。
</li>
</ul>
	 
<p>
	if (unlikely(!action || (desc-&gt;status &amp; IRQ_DISABLED)))
		goto out_unlock;
</p>
	
<p>
3. 平台处理函数在初始化的时候将所有GPIO都设置为电平触发
	set_irq_handler(gpio, handle_level_irq)
</p>
	
<p>
   而键盘设备自己注册了handle_edge_irq。
</p>
   
<p>
那么，为什么边沿处发的时候要处理IRQ_DISABLED的中断呢？
</p>
   
   
   

<p>
void
handle_edge_irq(unsigned int irq, struct irq_desc *desc)
{
	raw_spin_lock(&amp;desc-&gt;lock);
</p>

<p>
	desc-&gt;status &amp;= ~(IRQ_REPLAY | IRQ_WAITING);
</p>

<p>
	/*
</p>
<ul>
<li>
If we're currently running this IRQ, or its disabled,
</li>
<li>
we shouldn't process the IRQ. Mark it pending, handle
</li>
<li>
the necessary masking and go out
<br />	 */
<br />	if (unlikely((desc-&gt;status &amp; (IRQ_INPROGRESS | IRQ_DISABLED)) ||
<br />		    !desc-&gt;action)) {
<br />		desc-&gt;status |= (IRQ_PENDING | IRQ_MASKED);
<br />		mask_ack_irq(desc);
<br />		goto out_unlock;
<br />	}
<br />	kstat_incr_irqs_this_cpu(irq, desc);
</li>
</ul>

<p>
	/* Start handling the irq */
	desc-&gt;irq_data.chip-&gt;irq_ack(&amp;desc-&gt;irq_data);
</p>

<p>
	/* Mark the IRQ currently in progress.*/
	desc-&gt;status |= IRQ_INPROGRESS;
</p>

<p>
	do {
		struct irqaction *action = desc-&gt;action;
		irqreturn_t action_ret;
</p>

<p>
		if (unlikely(!action)) {
			mask_irq(desc);
			goto out_unlock;
		}
</p>

<p>
		/*
</p>
<ul>
<li>
When another irq arrived while we were handling
</li>
<li>
one, we could have masked the irq.
</li>
<li>
Renable it, if it was not disabled in meantime.
<br />		 */
<br />		if (unlikely((desc-&gt;status &amp;
<br />			       (IRQ_PENDING | IRQ_MASKED | IRQ_DISABLED)) ==
<br />			      (IRQ_PENDING | IRQ_MASKED))) {
<br />			unmask_irq(desc);
<br />		}
</li>
</ul>

<p>
		desc-&gt;status &amp;= ~IRQ_PENDING;
		raw_spin_unlock(&amp;desc-&gt;lock);
		action_ret = handle_IRQ_event(irq, action);
		if (!noirqdebug)
			note_interrupt(irq, desc, action_ret);
		raw_spin_lock(&amp;desc-&gt;lock);
</p>

<p>
	} while ((desc-&gt;status &amp; (IRQ_PENDING | IRQ_DISABLED)) == IRQ_PENDING);
</p>

<p>
	desc-&gt;status &amp;= ~IRQ_INPROGRESS;
out_unlock:
	raw_spin_unlock(&amp;desc-&gt;lock);
}
</p>


<p>
3. 休眠时的中断处理
</p>

<p>
dpm_suspend_noirq()
  -&gt; suspend_device_irqs()
</p>

<p>
总共有nr_irqs个中断号，循环，取每个中断号的断描述符irq_desc，
调用 __disable_irq(desc, irq, true); 禁止这个中断。
</p>

<p>
/**
</p>
<ul>
<li>
suspend_device_irqs - disable all currently enabled interrupt lines
<br /> *
</li>
<li>
During system-wide suspend or hibernation device drivers need to be prevented
</li>
<li>
from receiving interrupts and this function is provided for this purpose.
</li>
<li>
It marks all interrupt lines in use, except for the timer ones, as disabled
</li>
<li>
and sets the IRQ_SUSPENDED flag for each of them.
<br /> */
</li>
</ul>
 
<p>
// suspend_device_irqs - 禁止所有当前已使能的中断
// 
// 当系统休眠时，设备驱动需要禁止接收中断，此函数用于这种目的。它将屏蔽所有在
// 使用的中断(置IRQ_DISABLED标志)，timer中断除外，因为Timer中段标志中设置了
// IRQF_NO_SUSPEND。如果禁止原因是suspend，则设置标志中的IRQ_SUSPENDED位。
</p>

<p>
void suspend_device_irqs(void)
{
	struct irq_desc *desc;
	int irq;
</p>

<p>
	for_each_irq_desc(irq, desc) {
		unsigned long flags;
</p>

<p>
		raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);
		__disable_irq(desc, irq, true);
		raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
	}
</p>

<p>
	for_each_irq_desc(irq, desc)
		if (desc-&gt;status &amp; IRQ_SUSPENDED)
			synchronize_irq(irq);
}
</p>

<p>
void __disable_irq(struct irq_desc *desc, unsigned int irq, bool suspend)
{
	if (suspend) {
		//如果置了IRQF_NO_SUSPEND标志的话，则此中断在休眠时不会禁止
		if (!desc-&gt;action || (desc-&gt;action-&gt;flags &amp; IRQF_NO_SUSPEND))
			return;
		desc-&gt;status |= IRQ_SUSPENDED;
	}
</p>

<p>
	if (!desc-&gt;depth++) { //防止嵌套和重复禁止
		desc-&gt;status |= IRQ_DISABLED;
		desc-&gt;irq_data.chip-&gt;irq_disable(&amp;desc-&gt;irq_data);
		//调用平台相关代码禁止该中断。
		//我跟踪mx53的执行过程，这个指针指向default_disable()，
		//而这个函数什么都不做。
	}
}
</p>
 
 
<p>
 // 下面再来看一下中断触发后处理的流程，看看上面的设置有什么影响！！！
</p>

<p>
// arch/arm/kernel/irq.c
</p>

<p>
asm_do_IRQ()
  -&gt; generic_handle_irq(irq);
</p>
<blockquote>
-&gt; desc-&gt;handle_irq(irq, desc);
</blockquote>

<p>
set_irq_handler(i, handle_level_irq);
</p>

<p>
// kernel/irq/chip.c
</p>

<p>
handle_level_irq()
  -&gt; handle_IRQ_event(irq, action);
</p>

<p>
/**
</p>
<ul>
<li>
handle_level_irq - Level type irq handler
</li>
<li>
@irq:	the interrupt number
</li>
<li>
@desc:	the interrupt description structure for this irq
<br /> *
</li>
<li>
Level type interrupts are active as long as the hardware line has
</li>
<li>
the active level. This may require to mask the interrupt and unmask
</li>
<li>
it after the associated handler has acknowledged the device, so the
</li>
<li>
interrupt line is back to inactive.
<br /> */
</li>
</ul>
<p>
void
handle_level_irq(unsigned int irq, struct irq_desc *desc)
{
	struct irqaction *action;
	irqreturn_t action_ret;
</p>

<p>
	raw_spin_lock(&amp;desc-&gt;lock);
	mask_ack_irq(desc);
</p>

<p>
	if (unlikely(desc-&gt;status &amp; IRQ_INPROGRESS))
		goto out_unlock;
	desc-&gt;status &amp;= ~(IRQ_REPLAY | IRQ_WAITING);
	kstat_incr_irqs_this_cpu(irq, desc);
</p>

<p>
	/*
</p>
<ul>
<li>
If its disabled or no action available
</li>
<li>
keep it masked and get out of here
<br />	 */
<br />	action = desc-&gt;action;
<br />	// 如果设置了IRQ_DISABLED，就直接跳出来。
<br />	// 在suspend时禁止所有中断，就会将所有中断描述标志置IRQ_DISABLED
<br />	if (unlikely(!action || (desc-&gt;status &amp; IRQ_DISABLED)))
<br />		goto out_unlock;
</li>
</ul>

<p>
	desc-&gt;status |= IRQ_INPROGRESS;
	raw_spin_unlock(&amp;desc-&gt;lock);
</p>

<p>
	action_ret = handle_IRQ_event(irq, action);
	if (!noirqdebug)
		note_interrupt(irq, desc, action_ret);
</p>

<p>
	raw_spin_lock(&amp;desc-&gt;lock);
	desc-&gt;status &amp;= ~IRQ_INPROGRESS;
</p>

<p>
	if (!(desc-&gt;status &amp; (IRQ_DISABLED | IRQ_ONESHOT)))
		unmask_irq(desc);
out_unlock:
	raw_spin_unlock(&amp;desc-&gt;lock);
}
</p>

<p>
request_threaded_irq()
request_irq()
</p>



<p>
handle_nested_irq
handle_simple_irq
</p>

<p>
handle_level_irq
</p>

<p>
/**
</p>
<ul>
<li>
handle_level_irq - Level type irq handler
</li>
<li>
@irq:	the interrupt number
</li>
<li>
@desc:	the interrupt description structure for this irq
<br /> *
</li>
<li>
Level type interrupts are active as long as the hardware line has
</li>
<li>
the active level. This may require to mask the interrupt and unmask
</li>
<li>
it after the associated handler has acknowledged the device, so the
</li>
<li>
interrupt line is back to inactive.
<br /> */
</li>
</ul>

<p>
// 电平信号都会持续一段时间，或长或段。在这段时间内电平中断会一直被触发。
// 所以需要在执行中断处理之前屏蔽这个中断，待处理函数执行完毕之后再开启它。
// 于是接下来中断又被激活了。
</p>

<p>
void
handle_level_irq(unsigned int irq, struct irq_desc *desc)
{
	struct irqaction *action;
	irqreturn_t action_ret;
</p>

<p>
	raw_spin_lock(&amp;desc-&gt;lock);
	mask_ack_irq(desc);
</p>

<p>
	if (unlikely(desc-&gt;status &amp; IRQ_INPROGRESS))
		goto out_unlock;
	desc-&gt;status &amp;= ~(IRQ_REPLAY | IRQ_WAITING);
	kstat_incr_irqs_this_cpu(irq, desc);
</p>

<p>
	/*
</p>
<ul>
<li>
If its disabled or no action available
</li>
<li>
keep it masked and get out of here
<br />	 */
<br />	action = desc-&gt;action;
<br />	if (unlikely(!action || (desc-&gt;status &amp; IRQ_DISABLED)))
<br />		goto out_unlock;
</li>
</ul>

<p>
	desc-&gt;status |= IRQ_INPROGRESS;
	raw_spin_unlock(&amp;desc-&gt;lock);
</p>

<p>
	action_ret = handle_IRQ_event(irq, action);
	if (!noirqdebug)
		note_interrupt(irq, desc, action_ret);
</p>

<p>
	raw_spin_lock(&amp;desc-&gt;lock);
	desc-&gt;status &amp;= ~IRQ_INPROGRESS;
</p>

<p>
	if (!(desc-&gt;status &amp; (IRQ_DISABLED | IRQ_ONESHOT)))
		unmask_irq(desc);
out_unlock:
	raw_spin_unlock(&amp;desc-&gt;lock);
}
</p>

<p>
handle_fasteoi_irq
</p>

<p>
handle_edge_irq
</p>

<p>
/**
</p>
<ul>
<li>
handle_edge_irq - edge type IRQ handler
</li>
<li>
@irq:	the interrupt number
</li>
<li>
@desc:	the interrupt description structure for this irq
<br /> *
</li>
<li>
Interrupt occures on the falling and/or rising edge of a hardware
</li>
<li>
signal. The occurence is latched into the irq controller hardware
</li>
<li>
and must be acked in order to be reenabled. After the ack another
</li>
<li>
interrupt can happen on the same source even before the first one
</li>
<li>
is handled by the associated event handler. If this happens it
</li>
<li>
might be necessary to disable (mask) the interrupt depending on the
</li>
<li>
controller hardware. This requires to reenable the interrupt inside
</li>
<li>
of the loop which handles the interrupts which have arrived while
</li>
<li>
the handler was running. If all pending interrupts are handled, the
</li>
<li>
loop is left.
<br /> */
</li>
</ul>

<p>
上升沿或下降沿信号触发这个中断，中断发生事件会锁存直到中断控制器处理了它，并且
重新使能它。一旦应答了这个中断后，
</p>
	
<p>
如果当前中断正在处理或被禁止了，则锁存了此次中断的触发事件(置位IRQ_PENDING)
这样一来，这次中断不会被丢失。
</p>

<p>
	if (unlikely((desc-&gt;status &amp; (IRQ_INPROGRESS | IRQ_DISABLED)) ||
</p>
<blockquote>
!desc-&gt;action)) {
</blockquote>
<p>
		desc-&gt;status |= (IRQ_PENDING | IRQ_MASKED);
		mask_ack_irq(desc);
		goto out_unlock;
	}
</p>


<p>
handle_percpu_irq
</p>



<p>
键盘: tc35894 -&gt; handle_edge_irq
MR Sensor: gpio -&gt; handle_level_irq
</p>















<p>
enable_irq_wake(unsigned int irq)
  -&gt; set_irq_wake(irq, 1)
</p>
<blockquote>
-&gt; set_irq_wake_real(irq, on);
</blockquote>


<p>
static int set_irq_wake_real(unsigned int irq, unsigned int on)
{
	struct irq_desc *desc = irq_to_desc(irq);
	int ret = -ENXIO;
</p>

<p>
	if (desc-&gt;irq_data.chip-&gt;irq_set_wake)
		ret = desc-&gt;irq_data.chip-&gt;irq_set_wake(&amp;desc-&gt;irq_data, on);
</p>

<p>
	return ret;
}
</p>

<p>
// 根据函数指针，可以跟到平台代码里
// arch/arm/plat-mxc/gpio.c
</p>

<p>
static struct irq_chip gpio_irq_chip = {
	.name = "GPIO",
	.irq_ack = gpio_ack_irq,
	.irq_mask = gpio_mask_irq,
	.irq_unmask = gpio_unmask_irq,
	.irq_set_type = gpio_set_irq_type,
	.irq_set_wake = gpio_set_wake_irq,
};
</p>

<p>
//对于GPIO中断，有许多个GPIO口共用一个中断号，所以还要继续使能它的上一级中断号irq_high
static int gpio_set_wake_irq(struct irq_data *d, u32 enable)
{
	u32 gpio = irq_to_gpio(d-&gt;irq);
	u32 gpio_idx = gpio &amp; 0x1F;
	struct mxc_gpio_port *port = &amp;mxc_gpio_ports[gpio / 32];
</p>

<p>
	if (enable) {
		if (port-&gt;irq_high &amp;&amp; (gpio_idx &gt;= 16))
			enable_irq_wake(port-&gt;irq_high);
		else
			enable_irq_wake(port-&gt;irq);
	} else {
		if (port-&gt;irq_high &amp;&amp; (gpio_idx &gt;= 16))
			disable_irq_wake(port-&gt;irq_high);
		else
			disable_irq_wake(port-&gt;irq);
	}
</p>

<p>
	return 0;
}
</p>

<p>
// 直到最后来到中断控制器中 arch/arm/plat-mxc/tzic.c
static struct mxc_irq_chip mxc_tzic_chip = {
	.base = {
		.name = "MXC_TZIC",
		.irq_ack = tzic_mask_irq,
		.irq_mask = tzic_mask_irq,
		.irq_unmask = tzic_unmask_irq,
		.irq_set_wake = tzic_set_wake_irq,
	},
#ifdef CONFIG_FIQ
	.set_irq_fiq = tzic_set_irq_fiq,
#endif
};
</p>

<p>
static int mx5_suspend_enter(suspend_state_t state)
{
	if (gpc_dvfs_clk == NULL)
		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
	/* gpc clock is needed for SRPG */
	clk_enable(gpc_dvfs_clk);
	switch (state) {
	case PM_SUSPEND_MEM:
		//
		mxc_cpu_lp_set(STOP_POWER_OFF);
		break;
	case PM_SUSPEND_STANDBY:
		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
		break;
	default:
		return -EINVAL;
	}
</p>

<p>
	//
	if (tzic_enable_wake(0) != 0)
		return -EAGAIN;
</p>

<p>
	if (state == PM_SUSPEND_MEM) {
</p>

<p>
		// 调用电源管理芯片的休眠处理，主要是降低一些模块的电压
		if (pm_data &amp;&amp; pm_data-&gt;suspend_enter)
			pm_data-&gt;suspend_enter();
		if (cpu_is_mx51() || cpu_is_mx53()) {
			/* Run the suspend code from iRAM. */
			suspend_in_iram(suspend_param1, NULL, NULL);
			...
		} else {
			...
		}
		if (pm_data &amp;&amp; pm_data-&gt;suspend_exit)
			pm_data-&gt;suspend_exit();
	} else {
			cpu_do_idle();
	}
	clk_disable(gpc_dvfs_clk);
</p>

<p>
	return 0;
}
</p>

</body>
</html>
