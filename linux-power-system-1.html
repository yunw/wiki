<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css" />
<title>linux-power-system-1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<p>
<a href="http://disanji.net/">http://disanji.net/</a>
</p>

<p>
<a href="http://blog.chinaunix.net/space.php?uid=9012903&amp;do=blog&amp;id=2011492">http://blog.chinaunix.net/space.php?uid=9012903&amp;do=blog&amp;id=2011492</a>
</p>

<p>
<a href="http://blog.csdn.net/droidphone/article/details/6642081">http://blog.csdn.net/droidphone/article/details/6642081</a>
<a href="http://blog.csdn.net/lizhiguo0532?viewmode=contents">http://blog.csdn.net/lizhiguo0532?viewmode=contents</a>
</p>


<p>
Linux Suspend/Resume Framework
</p>

<ul>
<li>
On（on）                              S0 - Working
</li>
<li>
Standby （standby）                   S1 - CPU and RAM are powered but not executed
</li>
<li>
Suspend to RAM（mem）                 S3 - RAM is powered and the running content is saved to RAM
</li>
<li>
Suspend to Disk，Hibernation（disk）  S4 -  All contect is saved to Disk and power down
</li>
</ul>


<p>
kernel/power/main.c
</p>

<pre>
power_attr(state);

#define power_attr(_name) \
static struct kobj_attribute _name##_attr = {	\
	.attr	= {				\
		.name = __stringify(_name),	\
		.mode = 0644,			\
	},					\
	.show	= _name##_show,			\
	.store	= _name##_store,		\
}

展开后得到：
static struct kobj_attribute state_attr = {
	.attr = {
		.name = "state", 
		.mode = 0644, 
	}, 
	.show = state_show, 
	.store = state_store, 
};
</pre>
<p>
这里就注册了 state_show 和 state_store
</p>

<pre>

static int __init pm_init(void)
{
	...
	power_kobj = kobject_create_and_add("power", NULL);
	if (!power_kobj)
		return -ENOMEM;
	return sysfs_create_group(power_kobj, &amp;attr_group);
}
</pre>
<p>
这里就会创建 /sys/power/ 目录，以及该目录下的一系列属性文件，其中就有
/sys/power/state，对此文件的读/写会分别导致 state_store 和 state_show 的调用。
</p>

<p>
${ANDROID}/hardware/libhardware_legacy/power/power.c
</p>

<p>
应用程序调用 set_screen_state(int on) 向 /sys/power/state 写入相应字符串
</p>
<pre>
enum {
    ACQUIRE_PARTIAL_WAKE_LOCK = 0,
    RELEASE_WAKE_LOCK,
    REQUEST_STATE,
    OUR_FD_COUNT
};

const char * const NEW_PATHS[] = {
    "/sys/power/wake_lock",
    "/sys/power/wake_unlock",
    "/sys/power/state"
};

//开打NEW_PATHS里的文件，并将文件描述符保存到 g_fds[] 数组里
static int open_file_descriptors(const char * const paths[])
{
    int i;
    for (i=0; i&lt;OUR_FD_COUNT; i++) {
        int fd = open(paths[i], O_RDWR);
        if (fd &lt; 0) {
            fprintf(stderr, "fatal error opening \"%s\"\n", paths[i]);
            g_error = errno;
            return -1;
        }
        g_fds[i] = fd;
    }

    g_error = 0;
    return 0;
}
</pre>

<pre>
int set_screen_state(int on)
{
    ...

    char buf[32];
    int len;
    if(on)
        len = snprintf(buf, sizeof(buf), "%s", on_state);
    else
        len = snprintf(buf, sizeof(buf), "%s", off_state);

    buf[sizeof(buf) - 1] = '\0';
    len = write(g_fds[REQUEST_STATE], buf, len);
    if(len &lt; 0) {
        LOGE("Failed setting last user activity: g_error=%d\n", g_error);
    }
    return 0;
}
</pre>
  
<pre>
// 下面两个是用于操作 /sys/power/wake_lock 和 /sys/power/wake_unlock 的
int acquire_wake_lock(int lock, const char* id)
int release_wake_lock(const char* id)
</pre>

<ul>
<li>
可见上层应用程序就是通过下面这三个函数来进行电源管理的
<pre>
int set_screen_state(int on)
int acquire_wake_lock(int lock, const char* id)
int release_wake_lock(const char* id)
</pre>
</li>
</ul>


<h2 id="toc_0.1">kernel/power/</h2>

<p>
consoleearlysuspend.c
earlysuspend.c
fbearlysuspend.c
userwakelock.c
wakelock.c
include/linux/eralysuspend.h
include/linux/wakelock.h
</p>


<pre>
// 将 handler 加到 eraly_suspend_handlers 链表里
void register_early_suspend(struct early_suspend *handler)
{
	struct list_head *pos;

	mutex_lock(&amp;early_suspend_lock);
	list_for_each(pos, &amp;early_suspend_handlers) {
		struct early_suspend *e;
		e = list_entry(pos, struct early_suspend, link);
		if (e-&gt;level &gt; handler-&gt;level)
			break;
	}
	list_add_tail(&amp;handler-&gt;link, pos);
	if ((state &amp; SUSPENDED) &amp;&amp; handler-&gt;suspend)
		handler-&gt;suspend(handler);
	mutex_unlock(&amp;early_suspend_lock);
}
</pre>

<p>
再看前面提到的 state_store
</p>
<pre>
static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
			   const char *buf, size_t n)
{
#ifdef CONFIG_SUSPEND
#ifdef CONFIG_EARLYSUSPEND
	suspend_state_t state = PM_SUSPEND_ON;
#else
	suspend_state_t state = PM_SUSPEND_STANDBY;
#endif
	const char * const *s;
#endif
	char *p;
	int len;
	int error = -EINVAL;

	p = memchr(buf, '\n', n);
	len = p ? p - buf : n;

	/* First, check if we are requested to hibernate */
	...

#ifdef CONFIG_SUSPEND
	// 根据写入 state 文件的字符串与 pm_states[] 字符串数组中的相比较，决定
	// 当前要进入哪一种模式
	for (s = &amp;pm_states[state]; state &lt; PM_SUSPEND_MAX; s++, state++) {
		if (*s &amp;&amp; len == strlen(*s) &amp;&amp; !strncmp(buf, *s, len))
			break;
	}
	if (state &lt; PM_SUSPEND_MAX &amp;&amp; *s)
#ifdef CONFIG_EARLYSUSPEND
		if (state == PM_SUSPEND_ON || valid_state(state)) {
			error = 0;
			request_suspend_state(state);
		}
		//在真正执行 enter_state 之前，android 在这里实现 eralysuspend 的功能
#else
		error = enter_state(state);
#endif
#endif

 Exit:
	return error ? error : n;
}
</pre>
<p>
Android 在 enter_state 之前会调用 request_suspend_state(kernel/power/earlysuspend.c)
</p>

<pre>
// state 是一个全局变量，记录了当前的电源状态
void request_suspend_state(suspend_state_t new_state)
{
	unsigned long irqflags;
	int old_sleep;

	spin_lock_irqsave(&amp;state_lock, irqflags);
	old_sleep = state &amp; SUSPEND_REQUESTED;
	
	...
	
	if (!old_sleep &amp;&amp; new_state != PM_SUSPEND_ON) { // 进入suspend
		state |= SUSPEND_REQUESTED;
		queue_work(suspend_work_queue, &amp;early_suspend_work);
	} else if (old_sleep &amp;&amp; new_state == PM_SUSPEND_ON) { // resume
		state &amp;= ~SUSPEND_REQUESTED;
		wake_lock(&amp;main_wake_lock);
		queue_work(suspend_work_queue, &amp;late_resume_work);
	}
	requested_suspend_state = new_state;
	spin_unlock_irqrestore(&amp;state_lock, irqflags);
}
</pre>

<p>
根据请求的电源状态来决定当前是进入 suspend 还是 resume，进入 suspend 的情况，先
将 early_suspend_work 加入工作列队并调度执行它们。
</p>

<pre>
static DECLARE_WORK(early_suspend_work, early_suspend);

static void early_suspend(struct work_struct *work)
{
	struct early_suspend *pos;
	
	...

	list_for_each_entry(pos, &amp;early_suspend_handlers, link) {
		if (pos-&gt;suspend != NULL)
			pos-&gt;suspend(pos);
	}

	...
}

从 early_suspend_handlers 链表中顺序取出各驱动注册的 eraly_suspend, 然后执行其
中的 suspend 函数。
</pre>


<pre>
static void late_resume(struct work_struct *work)
{
	struct early_suspend *pos;
	
	...

	list_for_each_entry_reverse(pos, &amp;early_suspend_handlers, link)
		if (pos-&gt;resume != NULL)
			pos-&gt;resume(pos);
	...
}
从 eraly_suspend_handlers 链表中逆序取出各驱动注册的 eraly_suspend，然后执行其
中的 resume 函数。
</pre>


<p>
suspend_work_queue 在 kernel/power/wakelock.c 中创建
</p>

<ul>
<li>
wake_lock_init
<pre>
void wake_lock_init(struct wake_lock *lock, int type, const char *name)
新建一个锁，指定其类型type 和 名字name，将锁设置为初始状态(未锁住)
最后这个锁加入到 inactive_locks 链表中
</pre>
</li>
</ul>

<ul>
<li>
wake_lock
<pre>
void wake_lock(struct wake_lock *lock)
{
	wake_lock_internal(lock, 0, 0);
}
将锁从 inactive_locks 链表中删除， 将锁设置为锁住激活状态(WAKE_LOCK_ACTIVE)
然后加入到 active_wake_locks[type] 链表中
</pre>
</li>
</ul>

<ul>
<li>
wake_unlock
</li>
</ul>
<p>
将锁从原链表中删除，并加入到 inactive_locks 链表中，设置成未锁住状态
只要有对 WAKE_LOCK_SUSPEND 类型的锁解锁，就都有可能进入 suspend 状态。
</p>
<pre>
void wake_unlock(struct wake_lock *lock)
{
	int type;
	unsigned long irqflags;
	spin_lock_irqsave(&amp;list_lock, irqflags);
	type = lock-&gt;flags &amp; WAKE_LOCK_TYPE_MASK;
#ifdef CONFIG_WAKELOCK_STAT
	wake_unlock_stat_locked(lock, 0);
#endif
	if (debug_mask &amp; DEBUG_WAKE_LOCK)
		pr_info("wake_unlock: %s\n", lock-&gt;name);
	lock-&gt;flags &amp;= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
	list_del(&amp;lock-&gt;link);
	list_add(&amp;lock-&gt;link, &amp;inactive_locks);
	if (type == WAKE_LOCK_SUSPEND) { // 只有WAKE_LOCK_SUSPEND类型的锁才会阻止系统进入suspend
		long has_lock = has_wake_lock_locked(type); // 检查是否还有此类锁存在
		if (has_lock &gt; 0) {
			// 还有超时锁存在，修改定时器超时时间
			if (debug_mask &amp; DEBUG_EXPIRE)
				pr_info("wake_unlock: %s, start expire timer, "
					"%ld\n", lock-&gt;name, has_lock);
			mod_timer(&amp;expire_timer, jiffies + has_lock);
		} else {
			if (del_timer(&amp;expire_timer))
				if (debug_mask &amp; DEBUG_EXPIRE)
					pr_info("wake_unlock: %s, stop expire "
						"timer\n", lock-&gt;name);
			if (has_lock == 0) // 没有此类锁了，可以进入suspend了
				queue_work(suspend_work_queue, &amp;suspend_work);
			// 如果 has_lock &lt; 0，则说明有非超时锁存在，只能等待非超时锁自己wake_unlock
		}
		if (lock == &amp;main_wake_lock) {
			if (debug_mask &amp; DEBUG_SUSPEND)
				print_active_locks(WAKE_LOCK_SUSPEND);
#ifdef CONFIG_WAKELOCK_STAT
			update_sleep_wait_stats_locked(0);
#endif
		}
	}
	spin_unlock_irqrestore(&amp;list_lock, irqflags);
}
</pre>

</body>
</html>
